<html>

<head>
<meta http-equiv="Content-Type" content="text/html" charset="utf-8" />
<title>3D Game Design</title>
<script src="cannon.js"></script>
<script src="babylon.js"></script>
<script src="babylon.objFileLoader.min.js"></script> 
<object data="sound.wav" type="video/quicktime" width="0" height="0">
    <param name="filename" value="sound.wav">
    <param name="autostart" value="1">
    <param name="playcount" value="true"> 
</object>
<script> 
        function start() {
          var canvas = document.getElementById('renderCanvas');
          var engine = new BABYLON.Engine(canvas, true);
          var myMusic; myMusic = new sound("resources/Pirates of the Caribbean (Earrape).mp3");
            myMusic.play();
            var mySound;
          function sound(src) {
              this.sound = document.createElement("audio");
              this.sound.src = src;
              this.sound.setAttribute("preload", "auto");
              this.sound.setAttribute("controls", "none");
              this.sound.style.display = "none";
              document.body.appendChild(this.sound);
              this.play = function(){
                  this.sound.play();
              
              }
          }

           

          var keys = {};
          window.addEventListener('keydown', function(e) {
            keys[e.key] = true;
          });

          window.addEventListener('keyup', function(e) {
            keys[e.key] = false;
          }); 
          var scene = new BABYLON.Scene(engine); 

          var gravityVector = new BABYLON.Vector3(0, -9.81, 0);
          scene.enablePhysics(gravityVector, new BABYLON.CannonJSPlugin()); 

          scene.clearColor = new BABYLON.Color3(0.5, 0.8, 0.5); 

        //NEW CODE
        //===TRACK CODE===// 

         var _xFn = function(t) {var fns = [function(t) {return (Math.pow((1-t),3)*0.1275)+(3*t*Math.pow((1-t),2)*0.0125)+(3*Math.pow(t,2)*(1-t)*0.005)+(Math.pow(t,3)*0.6125)},function(t) {return (Math.pow((1-t),3)*0.6125)+(3*t*Math.pow((1-t),2)*1.22)+(3*Math.pow(t,2)*(1-t)*0.7875)+(Math.pow(t,3)*0.6175)},function(t) {return (Math.pow((1-t),3)*0.6175)+(3*t*Math.pow((1-t),2)*0.4475)+(3*Math.pow(t,2)*(1-t)*0.165)+(Math.pow(t,3)*0.7)},function(t) {return (Math.pow((1-t),3)*0.7)+(3*t*Math.pow((1-t),2)*1.235)+(3*Math.pow(t,2)*(1-t)*0.23)+(Math.pow(t,3)*0.2725)},function(t) {return (Math.pow((1-t),3)*0.2725)+(3*t*Math.pow((1-t),2)*0.315)+(3*Math.pow(t,2)*(1-t)*0)+(Math.pow(t,3)*0.385)},function(t) {return (Math.pow((1-t),3)*0.385)+(3*t*Math.pow((1-t),2)*0.77)+(3*Math.pow(t,2)*(1-t)*0.8025)+(Math.pow(t,3)*0.89)}];var i = Math.max(0,Math.min(5, Math.floor(t * 6)));return fns[i]((t - (i/6)) * 6);};
        var _yFn = function(t) {var fns = [function(t) {return (Math.pow((1-t),3)*0.0328125)+(3*t*Math.pow((1-t),2)*0.7103125)+(3*Math.pow(t,2)*(1-t)*0.9728125)+(Math.pow(t,3)*0.9978125)},function(t) {return (Math.pow((1-t),3)*0.9978125)+(3*t*Math.pow((1-t),2)*1.0228125)+(3*Math.pow(t,2)*(1-t)*0.0578125)+(Math.pow(t,3)*0.2428125)},function(t) {return (Math.pow((1-t),3)*0.2428125)+(3*t*Math.pow((1-t),2)*0.4278125)+(3*Math.pow(t,2)*(1-t)*0.4553125)+(Math.pow(t,3)*0.7703125)},function(t) {return (Math.pow((1-t),3)*0.7703125)+(3*t*Math.pow((1-t),2)*1.0853125)+(3*Math.pow(t,2)*(1-t)*0.7628125)+(Math.pow(t,3)*0.7428125)},function(t) {return (Math.pow((1-t),3)*0.7428125)+(3*t*Math.pow((1-t),2)*0.7228125)+(3*Math.pow(t,2)*(1-t)*0.4553125)+(Math.pow(t,3)*0.1528125)},function(t) {return (Math.pow((1-t),3)*0.1528125)+(3*t*Math.pow((1-t),2)*-0.1496875)+(3*Math.pow(t,2)*(1-t)*0.1953125)+(Math.pow(t,3)*0.3353125)}];var i = Math.max(0,Math.min(5, Math.floor(t * 6)));return fns[i]((t - (i/6)) * 6);};
        /* START CURVE DATA 
        {"start":[51,13.125],"init":[5,284.125],"segments":[{"a":[2,389.125],"b":[245,399.125]},{"a":[315,23.125],"b":[247,97.125]},{"a":[66,182.125],"b":[280,308.125]},{"a":[92,305.125],"b":[109,297.125]},{"a":[0,182.125],"b":[154,61.125]},{"a":[321,78.125],"b":[356,134.125]}]}
           END CURVE DATA */
           
                //===END TRACK CODE===// 

        var xFn = function(t) { return 650 * _xFn(t); }
        var zFn = function(t) { return 650 * _yFn(t); } 
        //END NEW CODE

          var playerSphere = BABYLON.MeshBuilder.CreateSphere("playerSphere", {
            segments: 12,
            diameter: 4
          }, scene);
          playerSphere.material = new BABYLON.StandardMaterial("playerSphereMaterial", scene);
          playerSphere.material.diffuseTexture = new BABYLON.Texture('resources/BeachBallColor.jpg', scene);
          //EDIT CODE BELOW
            //playerSphere.position = new BABYLON.Vector3(0, 5, 0);
          playerSphere.position = new BABYLON.Vector3(xFn(0), 9, zFn(0)); 
          //END EDIT CODE:
          playerSphere.physicsImpostor = new BABYLON.PhysicsImpostor(playerSphere, BABYLON.PhysicsImpostor.SphereImpostor, {
              mass: 1,
              restitution: 0.9
          }, scene);

          BABYLON.SceneLoader.ImportMesh(null, "resources/", "weird.obj", scene, function(meshes) {
        var boostMesh = meshes[0], boosts = [];
        boostMesh.material = new BABYLON.StandardMaterial("boostMaterial", scene);
        boostMesh.material.diffuseColor = new BABYLON.Color3(1, 1, 0);
        boostMesh.scaling = new BABYLON.Vector3(.05, 0.01, .05);
        boostMesh.setEnabled(false);
        function boostAt(xFn, zFn, t) {
        var newBoost = boostMesh.clone('boost');
        newBoost.position = new BABYLON.Vector3(xFn(t), 3.2, zFn(t));
        newBoost.rotation.y = -derivAngle(t, xFn, zFn);
        newBoost.setEnabled(true);
        boosts.push(newBoost);
        }

        // Place boosts here
        boostAt(xFn, zFn, 0.05);
        boostAt(xFn, zFn, 0.12);
        boostAt(xFn, zFn, 0.55);
        boostAt(xFn, zFn, 0.65);
        boostAt(xFn, zFn, 0.19);
        boostAt(xFn, zFn, 0.6);
        boostAt(xFn, zFn, 0.64);
        boostAt(xFn, zFn, 0.27);
        boostAt(xFn, zFn, 0.81);
        

        scene.registerAfterRender(function() {
        boosts.forEach(function(boost, i){
        if(boost.intersectsMesh(playerSphere)){
        boost.dispose();
        boosts.splice(i,1);
        var vel = playerSphere.physicsImpostor.getLinearVelocity();
        playerSphere.applyImpulse(vel.normalize().scale(100), playerSphere.getAbsolutePosition());
        } else {
        boost.rotation.y += 0.01
        }
        });
        });
        }); 

          var camera = new BABYLON.ArcRotateCamera("Camera", 0, (3 * Math.PI) / 8, 20, playerSphere, scene); 
          camera.attachControl(canvas, true);

          var light = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0, 1, 0), scene);
          rampAt(xFn, zFn, 0.17, -Math.PI / 4, scene);
          rampAt(xFn, zFn, 0.10, -Math.PI / 4, scene);
          rampAt(xFn, zFn, 0.6, -Math.PI / 4, scene);
          rampAt(xFn, zFn, 0.7, -Math.PI / 4, scene);
          rampAt(xFn, zFn, 0.24, -Math.PI / 4, scene);
          rampAt(xFn, zFn, 0.65, -Math.PI / 4, scene);
          rampAt(xFn, zFn, 0.69, -Math.PI / 4, scene);
          rampAt(xFn, zFn, 0.32, -Math.PI / 4, scene);
          rampAt(xFn, zFn, 0.86, -Math.PI / 4, scene);
          wallAt(xFn, zFn, 0.02, -6.1, scene);  
          wallAt(xFn, zFn, 0.17,- 6.1, scene); 
          wallAt(xFn, zFn, 0.10,- 6.1, scene); 
          wallAt(xFn, zFn, 0.04,- 6.1, scene); 
          wallAt(xFn, zFn, 0.05,- 6.1, scene);
          wallAt(xFn, zFn, 0.60,- 6.1, scene);
          wallAt(xFn, zFn, 0.7, -6.1, scene);
          wallAt(xFn, zFn, 0.24,- 6.1, scene);
          wallAt(xFn, zFn, 0.65, -6.1, scene);
          wallAt(xFn, zFn, 0.69, -6.1, scene);
          wallAt(xFn, zFn, 0.32, -6.1, scene);
          wallAt(xFn, zFn, 0.86, -6.1, scene);
          wallAt(xFn, zFn, 0.02, 6.1, scene); 
          wallAt(xFn, zFn, 0.17, 6.1, scene); 
          wallAt(xFn, zFn, 0.10, 6.1, scene); 
          wallAt(xFn, zFn, 0.04, 6.1, scene); 
          wallAt(xFn, zFn, 0.05, 6.1, scene);
          wallAt(xFn, zFn, 0.60, 6.1, scene);
          wallAt(xFn, zFn, 0.7, 6.1, scene);
          wallAt(xFn, zFn, 0.24, 6.1, scene);
          wallAt(xFn, zFn, 0.65, 6.1, scene);
          wallAt(xFn, zFn, 0.69, 6.1, scene);
          wallAt(xFn, zFn, 0.32, 6.1, scene);
          wallAt(xFn, zFn, 0.86, 6.1, scene); 
          


var startTime;
          var timer = document.querySelector('#timer');
         



          scene.registerAfterRender(function() { 
            var vel = playerSphere.physicsImpostor.getLinearVelocity();
            playerSphere.physicsImpostor.setLinearVelocity(vel.scale(.98)); 

            var forward = camera.getFrontPosition(1).subtract(camera.position);
            forward.y = 0;
            forward = forward.normalize().scale(1); 

            var backward = BABYLON.Vector3.TransformCoordinates(forward, BABYLON.Matrix.RotationY(Math.PI));

            var left = BABYLON.Vector3.TransformCoordinates(forward, BABYLON.Matrix.RotationY((3 * Math.PI) / 2));

            var right = BABYLON.Vector3.TransformCoordinates(forward, BABYLON.Matrix.RotationY(Math.PI / 2));

            if (keys.w) {
              if(!startTime){ startTime = Date.now(); } 
              playerSphere.applyImpulse(forward, playerSphere.getAbsolutePosition());
            }
            if (keys.s) {
              playerSphere.applyImpulse(backward, playerSphere.getAbsolutePosition());
            }
            if (keys.a) {
              playerSphere.applyImpulse(left, playerSphere.getAbsolutePosition());
            }
            if (keys.d) {
              playerSphere.applyImpulse(right, playerSphere.getAbsolutePosition());
            } 
            var currentT = tLookup(xFn, zFn, 500, playerSphere.position.x, playerSphere.position.z);
            var angle = (derivAngle(currentT, xFn, zFn) - (Math.PI)); 
            camera.alpha += (angle - camera.alpha) / 32; 

            if (currentT > 0.99) {
            win();
            } 
            
            if (playerSphere.position.y < -10) {
              lost();
            }
              if(startTime) {
            timer.innerHTML = ((Date.now() - startTime) / 1000).toFixed(2).replace('.',':');
                  
             
            } 
        }); 
          var mySound;
          function sound(src) {
              this.sound = document.createElement("audio");
              this.sound.src = src;
              this.sound.setAttribute("preload", "auto");
              this.sound.setAttribute("controls", "none");
              this.sound.style.display = "none";
              document.body.appendChild(this.sound);
              this.play = function(){
                  this.sound.play();
              }
              this.stop = function(){
                  this.sound.pause();
              }
          }


          function drawPoint(x, z, zrot, scene) {
            var point = BABYLON.MeshBuilder.CreateBox('point', { 
              width: 10, 
              height: 0.5, 
              depth: 12 
            }, scene);
            point.material = new BABYLON.StandardMaterial("pointMaterial", scene);
            point.material.diffuseColor = new BABYLON.Color3(1, 0, 1);
            point.position = new BABYLON.Vector3(x, 0.1, z);
            point.rotation.y = zrot;
            point.physicsImpostor = new BABYLON.PhysicsImpostor(point, BABYLON.PhysicsImpostor.BoxImpostor, {
              mass: 0,
              restitution: 0.9
            }, scene);
          }
        //NEW CODE
          function drawParametric(xFn, zFn, start, end, res, scene) {
            for (var t = start; t <= end; t += ((end - start) / res)) {
              drawPoint(xFn(t), zFn(t), 0, scene);
            }
          } 
        //END NEW CODE
        //REPLACE CODE BELOW
          //drawPoint(0, 0, 0, scene); 
          drawParametric(xFn, zFn, 0, 1, 1000, scene); 
        //END REPLACE CODE TO THE ABOVE 
        function tLookup(xFn, zFn, res, x, z) {
        var minT = 0;
        var minDist = Infinity;
        for (var t = 0; t <= 1; t += (1 / res)) {
        var dist = Math.pow(x - xFn(t), 2) + Math.pow(z - zFn(t), 2);
        if (dist < minDist) {
        minDist = dist;
        minT = t;
        }
        }
        return minT;
        } 
        function derivAngle(t, xFn, zFn) {
        function derive(f, x) {
        var h = 2.2e-10;
        return (f(x + h) - f(x - h)) / (2 * h);
        }
        return Math.atan2(derive(zFn, t), derive(xFn, t));
        } 
        function rampAt(xFn, zFn, t, angle, scene) {
        var ramp = BABYLON.MeshBuilder.CreateBox('ramp', {
        height: 8,
        width: .25,
        depth: 12
        }, scene);
        ramp.material = new BABYLON.StandardMaterial("rampMaterial", scene);
        ramp.material.diffuseColor = new BABYLON.Color3(1, 1, 0);
        ramp.physicsImpostor = new BABYLON.PhysicsImpostor(ramp, BABYLON.PhysicsImpostor.BoxImpostor, {
        mass: 0,
        restitution: 0.9
        }, scene);
        ramp.position = new BABYLON.Vector3(xFn(t), 3.2, zFn(t));

        ramp.rotation.z = angle;
        ramp.rotation.y = -derivAngle(t, xFn, zFn);
        } 
        function wallAt(xFn, zFn, t, offset, scene) {
        var wall = BABYLON.MeshBuilder.CreateBox('wall', {
        height: 8,
        width: .25,
        depth: 12
        }, scene);
        angle = -derivAngle(t, xFn, zFn); 
        wall.material = new BABYLON.StandardMaterial("wallMaterial", scene);
        wall.material.diffuseColor = new BABYLON.Color3(1, 1, 0);
        wall.physicsImpostor = new BABYLON.PhysicsImpostor(wall, BABYLON.PhysicsImpostor.BoxImpostor, {
        mass: 0,
        restitution: 0.9
        }, scene);
        wall.position = new BABYLON.Vector3(xFn(t) + (offset * Math.sin(angle)), 4, zFn(t) + (offset * Math.cos(angle)));
        wall.rotation.y = angle + (Math.PI / 2);
        return wall;
        } 


          engine.runRenderLoop(scene.render.bind(scene));
          window.addEventListener('resize', engine.resize.bind(engine)); 
        }
        function win(){
        window.location.reload();
        alert("You WIN!");
        } 


        function lost(){
          window.location.reload();
          alert("you lose!");
        } 
        </script> 
          <style>
            html, body {
              overflow: hidden;
              width: 100%;
              height: 100%;
              margin: 0;
              padding: 0;
            }
            #renderCanvas {
              width: 100%;
              height: 100%;
              touch-action: none;
            }
            #timer {
            position: absolute;
            left:10px;
            bottom:10px;
            color:#ccc;
            font: 52px sans-serif;
            } 

  </style>
</head> 
<body onload="start()"> 
<canvas id="renderCanvas"></canvas>
<div id="timer">00:00</div> 
</body> 
</html> 